Source Line  Source                                                                                    CPU Time  Spin Time  Overhead Time
-----------  ----------------------------------------------------------------------------------------  --------  ---------  -------------
235              // vec& ux(int ix, int iy)   { return ux_[offset(ix,iy)]; }                                                             
236              // vec& uy(int ix, int iy)   { return uy_[offset(ix,iy)]; }                                                             
237              // vec& fx(int ix, int iy)   { return fx_[offset(ix,iy)]; }                                                             
238              // vec& gy(int ix, int iy)   { return gy_[offset(ix,iy)]; }                                                             
239                                                                                                                                      
240              real& u0(int ix, int iy)    { return u0_[offset(ix,iy)]; }                                                              
241              real& v0(int ix, int iy)    { return v0_[offset(ix,iy)]; }                                                              
242              real& f0(int ix, int iy)    { return f0_[offset(ix,iy)]; }                                                              
243              real& g0(int ix, int iy)    { return g0_[offset(ix,iy)]; }                                                              
244                                                                                                                                      
245              real& ux0(int ix, int iy)   { return ux0_[offset(ix,iy)]; }                                                             
246              real& uy0(int ix, int iy)   { return uy0_[offset(ix,iy)]; }                                                             
247              real& fx0(int ix, int iy)   { return fx0_[offset(ix,iy)]; }                                                             
248              real& gy0(int ix, int iy)   { return gy0_[offset(ix,iy)]; }                                                             
249                                                                                                                                      
250                                                                                                                                      
251              real& u1(int ix, int iy)    { return u1_[offset(ix,iy)]; }                                                              
252              real& v1(int ix, int iy)    { return v1_[offset(ix,iy)]; }                                                              
253              real& f1(int ix, int iy)    { return f1_[offset(ix,iy)]; }                                                              
254              real& g1(int ix, int iy)    { return g1_[offset(ix,iy)]; }                                                              
255                                                                                                                                      
256              real& ux1(int ix, int iy)   { return ux1_[offset(ix,iy)]; }                                                             
257              real& uy1(int ix, int iy)   { return uy1_[offset(ix,iy)]; }                                                             
258              real& fx1(int ix, int iy)   { return fx1_[offset(ix,iy)]; }                                                             
259              real& gy1(int ix, int iy)   { return gy1_[offset(ix,iy)]; }                                                             
260                                                                                                                                      
261                                                                                                                                      
262              real& u2(int ix, int iy)    { return u2_[offset(ix,iy)]; }                                                              
263              real& v2(int ix, int iy)    { return v2_[offset(ix,iy)]; }                                                              
264              real& f2(int ix, int iy)    { return f2_[offset(ix,iy)]; }                                                              
265              real& g2(int ix, int iy)    { return g2_[offset(ix,iy)]; }                                                              
266                                                                                                                                      
267              real& ux2(int ix, int iy)   { return ux2_[offset(ix,iy)]; }                                                             
268              real& uy2(int ix, int iy)   { return uy2_[offset(ix,iy)]; }                                                             
269              real& fx2(int ix, int iy)   { return fx2_[offset(ix,iy)]; }                                                             
270              real& gy2(int ix, int iy)   { return gy2_[offset(ix,iy)]; }                                                             
271                                                                                                                                      
272              // Wrapped accessor (periodic BC)                                                                                       
273              int ioffset(int ix, int iy) {                                                                                           
274                  return offset( (ix+nx-nghost) % nx + nghost,                                                                        
275                                 (iy+ny-nghost) % ny + nghost );                                                                      
276              }                                                                                                                       
277                                                                                                                                      
278              real& uwrap0(int ix, int iy)  { return u0_[ioffset(ix,iy)]; }                                                           
279              real& uwrap1(int ix, int iy)  { return u1_[ioffset(ix,iy)]; }                                                           
280              real& uwrap2(int ix, int iy)  { return u2_[ioffset(ix,iy)]; }                                                           
281              // vec& uwrap(int ix, int iy)  { return u_[ioffset(ix,iy)]; }                                                           
282                                                                                                                                      
283              // Apply limiter to all components in a vector                                                                          
284              static void limdiff(real& du, const real& um, const real& u0, const real& up) {                                         
285                  du = Limiter::limdiff(um, u0, up);                                                  0.282s         0s             0s
286              }                                                                                                                       
287              // static void limdiff(vec& du, const vec& um, const vec& u0, const vec& up) {                                          
288              //     for (int m = 0; m < du.size(); ++m)                                                                              
289              //         du[m] = Limiter::limdiff(um[m], u0[m], up[m]);                                                               
290              // }                                                                                                                    
291                                                                                                                                      
292              // Stages of the main algorithm                                                                                         
293              void apply_periodic();                                                                                                  
294              void compute_fg_speeds(real& cx, real& cy);                                                                             
295              void limited_derivs();                                                                                                  
296              void compute_step(int io, real dt);                                                                                     
297                                                                                                                                      
298          };                                                                                                                          
299                                                                                                                                      
300                                                                                                                                      
301          /**                                                                                                                         
302           * ## Initialization                                                                                                        
303           *                                                                                                                          
304           * Before starting the simulation, we need to be able to set the                                                            
305           * initial conditions.  The `init` function does exactly this by                                                            
306           * running a callback function at the center of each cell in order                                                          
307           * to initialize the cell $U$ value.  For the purposes of this function,                                                    
308           * cell $(i,j)$ is the subdomain                                                                                            
309           * $[i \Delta x, (i+1) \Delta x] \times [j \Delta y, (j+1) \Delta y]$.                                                      
310           */                                                                                                                         
311                                                                                                                                      
312          template <class Physics, class Limiter>                                                                                     
313          template <typename F>                                                                                                       
314          void Central2D<Physics, Limiter>::init(F f)                                                                                 
315          {                                                                                                                           
316              for (int iy = 0; iy < ny; ++iy) {                                                                                       
317                  #pragma ivdep                                                                                                       
318                  for (int ix = 0; ix < nx; ++ix) {                                                                                   
319                      f(u0(nghost+ix,nghost+iy), u1(nghost+ix,nghost+iy), u2(nghost+ix,nghost+iy),                                    
320                        (ix+0.5)*dx, (iy+0.5)*dy);                                                                                    
321                      // f(u(nghost+ix,nghost+iy), (ix+0.5)*dx, (iy+0.5)*dy);                                                         
322                  }                                                                                                                   
323              }                                                                                                                       
324          }                                                                                                                           
325                                                                                                                                      
326          /**                                                                                                                         
327           * ## Time stepper implementation                                                                                           
328           *                                                                                                                          
329           * ### Boundary conditions                                                                                                  
330           *                                                                                                                          
331           * In finite volume methods, boundary conditions are typically applied by                                                   
332           * setting appropriate values in ghost cells.  For our framework, we will                                                   
333           * apply periodic boundary conditions; that is, waves that exit one side                                                    
334           * of the domain will enter from the other side.                                                                            
335           *                                                                                                                          
336           * We apply the conditions by assuming that the cells with coordinates                                                      
337           * `nghost <= ix <= nx+nghost` and `nghost <= iy <= ny+nghost` are                                                          
338           * "canonical", and setting the values for all other cells `(ix,iy)`                                                        
339           * to the corresponding canonical values `(ix+p*nx,iy+q*ny)` for some                                                       
340           * integers `p` and `q`.                                                                                                    
341           */                                                                                                                         
342                                                                                                                                      
343          template <class Physics, class Limiter>                                                                                     
344          void Central2D<Physics, Limiter>::apply_periodic()                                                                          
345          {                                                                                                                           
346              // Copy data between right and left boundaries                                                                          
347              for (int iy = 0; iy < ny_all; ++iy)                                                                                     
348                  #pragma ivdep                                                                                                       
349                  for (int ix = 0; ix < nghost; ++ix) {                                                                               
350                      // u(ix,          iy) = uwrap(ix,          iy);                                                                 
351                      // u(nx+nghost+ix,iy) = uwrap(nx+nghost+ix,iy);                                                                 
352                      u0(ix,          iy) = uwrap0(ix,          iy);                                                                  
353                      u0(nx+nghost+ix,iy) = uwrap0(nx+nghost+ix,iy);                                                                  
354                      u1(ix,          iy) = uwrap1(ix,          iy);                                                                  
355                      u1(nx+nghost+ix,iy) = uwrap1(nx+nghost+ix,iy);                                                                  
356                      u2(ix,          iy) = uwrap2(ix,          iy);                                                                  
357                      u2(nx+nghost+ix,iy) = uwrap2(nx+nghost+ix,iy);                                                                  
358                  }                                                                                                                   
359                                                                                                                                      
360              // Copy data between top and bottom boundaries                                                                          
361              for (int ix = 0; ix < nx_all; ++ix)                                                                                     
362                  #pragma ivdep                                                                                                       
363                  for (int iy = 0; iy < nghost; ++iy) {                                                                               
364                      u0(ix,          iy) = uwrap0(ix,          iy);                                                                  
365                      u0(ix,ny+nghost+iy) = uwrap0(ix,ny+nghost+iy);                                                                  
366                      u1(ix,          iy) = uwrap1(ix,          iy);                                                                  
367                      u1(ix,ny+nghost+iy) = uwrap1(ix,ny+nghost+iy);                                                                  
368                      u2(ix,          iy) = uwrap2(ix,          iy);                                                                  
369                      u2(ix,ny+nghost+iy) = uwrap2(ix,ny+nghost+iy);                                                                  
370                  }                                                                                                                   
371          }                                                                                                                           
372                                                                                                                                      
373                                                                                                                                      
374          /**                                                                                                                         
375           * ### Initial flux and speed computations                                                                                  
376           *                                                                                                                          
377           * At the start of each time step, we need the flux values at                                                               
378           * cell centers (to advance the numerical method) and a bound                                                               
379           * on the wave speeds in the $x$ and $y$ directions (so that                                                                
380           * we can choose a time step that respects the specified upper                                                              
381           * bound on the CFL number).                                                                                                
382           */                                                                                                                         
383                                                                                                                                      
384          template <class Physics, class Limiter>                                                                                     
385          void Central2D<Physics, Limiter>::compute_fg_speeds(real& cx_, real& cy_)                                                   
386          {                                                                                                                           
387              using namespace std;                                                                                                    
388              real cx = 1.0e-15;                                                                                                      
389              real cy = 1.0e-15;                                                                                                      
390              for (int iy = 0; iy < ny_all; ++iy)                                                                                     
391                  #pragma ivdep                                                                                                       
392                  for (int ix = 0; ix < nx_all; ++ix) {                                                                               
393                      real cell_cx, cell_cy;                                                                                          
394                      Physics::flux(f0(ix,iy), g0(ix,iy), u0(ix,iy),                                                                  
395                                    f1(ix,iy), g1(ix,iy), u1(ix,iy),                                                                  
396                                    f2(ix,iy), g2(ix,iy), u2(ix,iy));                                                                 
397                      Physics::wave_speed(cell_cx, cell_cy,                                                                           
398                                          u0(ix,iy), u1(ix,iy), u2(ix,iy));                                                           
399                      cx = max(cx, cell_cx);                                                                                          
400                      cy = max(cy, cell_cy);                                                                                          
401                  }                                                                                                                   
402              cx_ = cx;                                                                                                               
403              cy_ = cy;                                                                                                               
404          }                                                                                                                           
405                                                                                                                                      
406          /**                                                                                                                         
407           * ### Derivatives with limiters                                                                                            
408           *                                                                                                                          
409           * In order to advance the time step, we also need to estimate                                                              
410           * derivatives of the fluxes and the solution values at each cell.                                                          
411           * In order to maintain stability, we apply a limiter here.                                                                 
412           */                                                                                                                         
413                                                                                                                                      
414          template <class Physics, class Limiter>                                                                                     
415          void Central2D<Physics, Limiter>::limited_derivs()                                                                          
416          {                                                                                                                           
417              //x derivatives                                                                                                         
418              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
419              //     #pragma ivdep                                                                                                    
420              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
421              //         limdiff( ux0(ix,iy), u0(ix-1,iy), u0(ix,iy), u0(ix+1,iy) );                                                  
422              //     }                                                                                                                
423              // }                                                                                                                    
424              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
425              //     #pragma ivdep                                                                                                    
426              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
427              //         limdiff( fx0(ix,iy), f0(ix-1,iy), f0(ix,iy), f0(ix+1,iy) );                                                  
428              //     }                                                                                                                
429              // }                                                                                                                    
430              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
431              //     #pragma ivdep                                                                                                    
432              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
433              //         limdiff( ux1(ix,iy), u1(ix-1,iy), u1(ix,iy), u1(ix+1,iy) );                                                  
434              //     }                                                                                                                
435              // }                                                                                                                    
436              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
437              //     #pragma ivdep                                                                                                    
438              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
439              //         limdiff( fx1(ix,iy), f1(ix-1,iy), f1(ix,iy), f1(ix+1,iy) );                                                  
440              //     }                                                                                                                
441              // }                                                                                                                    
442              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
443              //     #pragma ivdep                                                                                                    
444              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
445              //         limdiff( ux2(ix,iy), u2(ix-1,iy), u2(ix,iy), u2(ix+1,iy) );                                                  
446              //     }                                                                                                                
447              // }                                                                                                                    
448              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
449              //     #pragma ivdep                                                                                                    
450              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
451              //         limdiff( fx2(ix,iy), f2(ix-1,iy), f2(ix,iy), f2(ix+1,iy) );                                                  
452              //     }                                                                                                                
453              // }                                                                                                                    
454                                                                                                                                      
455              // //y derivatives                                                                                                      
456              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
457              //     #pragma ivdep                                                                                                    
458              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
459              //         limdiff( gy0(ix,iy), g0(ix,iy-1), g0(ix,iy), g0(ix,iy+1) );                                                  
460              //     }                                                                                                                
461              // }                                                                                                                    
462              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
463              //     #pragma ivdep                                                                                                    
464              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
465              //         limdiff( uy1(ix,iy), u1(ix,iy-1), u1(ix,iy), u1(ix,iy+1) );                                                  
466              //     }                                                                                                                
467              // }                                                                                                                    
468              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
469              //     #pragma ivdep                                                                                                    
470              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
471              //         limdiff( gy1(ix,iy), g1(ix,iy-1), g1(ix,iy), g1(ix,iy+1) );                                                  
472              //     }                                                                                                                
473              // }                                                                                                                    
474              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
475              //     #pragma ivdep                                                                                                    
476              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
477              //         limdiff( uy0(ix,iy), u0(ix,iy-1), u0(ix,iy), u0(ix,iy+1) );                                                  
478              //     }                                                                                                                
479              // }                                                                                                                    
480              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
481              //     #pragma ivdep                                                                                                    
482              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
483              //         limdiff( uy2(ix,iy), u2(ix,iy-1), u2(ix,iy), u2(ix,iy+1) );                                                  
484              //     }                                                                                                                
485              // }                                                                                                                    
486              // for (int iy = 1; iy < ny_all-1; ++iy) {                                                                              
487              //     #pragma ivdep                                                                                                    
488              //     for (int ix = 1; ix < nx_all-1; ++ix) {                                                                          
489              //         limdiff( gy2(ix,iy), g2(ix,iy-1), g2(ix,iy), g2(ix,iy+1) );                                                  
490              //     }                                                                                                                
491              // }                                                                                                                    
492              for (int iy = 1; iy < ny_all-1; ++iy) {                                                                                 
493                  #pragma ivdep                                                                                                       
494                  for (int ix = 1; ix < nx_all-1; ++ix) {                                             0.003s         0s             0s
495                      // x derivs                                                                                                     
496                      limdiff( ux0(ix,iy), u0(ix-1,iy), u0(ix,iy), u0(ix+1,iy) );                                                     
497                      limdiff( fx0(ix,iy), f0(ix-1,iy), f0(ix,iy), f0(ix+1,iy) );                                                     
498                      limdiff( ux1(ix,iy), u1(ix-1,iy), u1(ix,iy), u1(ix+1,iy) );                                                     
499                      limdiff( fx1(ix,iy), f1(ix-1,iy), f1(ix,iy), f1(ix+1,iy) );                                                     
500                      limdiff( ux2(ix,iy), u2(ix-1,iy), u2(ix,iy), u2(ix+1,iy) );                                                     
501                      limdiff( fx2(ix,iy), f2(ix-1,iy), f2(ix,iy), f2(ix+1,iy) );                                                     
502                                                                                                                                      
503                      // y derivs                                                                                                     
504                      limdiff( uy0(ix,iy), u0(ix,iy-1), u0(ix,iy), u0(ix,iy+1) );                                                     
505                      limdiff( gy0(ix,iy), g0(ix,iy-1), g0(ix,iy), g0(ix,iy+1) );                                                     
506                      limdiff( uy1(ix,iy), u1(ix,iy-1), u1(ix,iy), u1(ix,iy+1) );                                                     
507                      limdiff( gy1(ix,iy), g1(ix,iy-1), g1(ix,iy), g1(ix,iy+1) );                                                     
508                      limdiff( uy2(ix,iy), u2(ix,iy-1), u2(ix,iy), u2(ix,iy+1) );                                                     
509                      limdiff( gy2(ix,iy), g2(ix,iy-1), g2(ix,iy), g2(ix,iy+1) );                                                     
510                                                                                                                                      
511                      // // x derivs                                                                                                  
512                      // limdiff( ux(ix,iy), u(ix-1,iy), u(ix,iy), u(ix+1,iy) );                                                      
513                      // limdiff( fx(ix,iy), f(ix-1,iy), f(ix,iy), f(ix+1,iy) );                                                      
514                                                                                                                                      
515                      // // y derivs                                                                                                  
516                      // limdiff( uy(ix,iy), u(ix,iy-1), u(ix,iy), u(ix,iy+1) );                                                      
517                      // limdiff( gy(ix,iy), g(ix,iy-1), g(ix,iy), g(ix,iy+1) );                                                      
518                  }                                                                                                                   
519              }                                                                                                                       
520          }                                                                                                                           
521                                                                                                                                      
522                                                                                                                                      
523          /**                                                                                                                         
524           * ### Advancing a time step                                                                                                
525           *                                                                                                                          
